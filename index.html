<!DOCTYPE html>
<html>
<head>
  <title>VR Solar System — Stars (Fixed)</title>
  <meta charset="utf-8" />
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #error {
      position: absolute; left: 10px; top: 10px; padding: 8px 12px;
      background: rgba(255,80,80,0.95); color: white; font-family: monospace;
      display: none; z-index: 10; border-radius: 6px;
    }
  </style>
</head>
<body>
<div id="error"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
(function(){
  const showError = (msg) => {
    console.error(msg);
    const el = document.getElementById('error');
    el.textContent = String(msg);
    el.style.display = 'block';
  };

  // Check WebGL availability quickly
  try {
    const canvasTest = document.createElement('canvas');
    const gl = canvasTest.getContext('webgl') || canvasTest.getContext('experimental-webgl');
    if (!gl) {
      showError('WebGL not available in this browser. Try Chrome/Firefox or enable WebGL.');
      return;
    }
  } catch (err) {
    showError('Error checking WebGL: ' + err);
    return;
  }

  let scene, camera, renderer;
  try {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 40);
    camera.lookAt(0,0,0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000); // black background
    document.body.appendChild(renderer.domElement);

  } catch (err) {
    showError('Failed to create renderer / camera: ' + err);
    return;
  }

  // Lights
  const ambient = new THREE.AmbientLight(0x444444);
  scene.add(ambient);

  const sunLight = new THREE.PointLight(0xffffff, 2, 1000);
  sunLight.position.set(0, 0, 0); // place at sun
  scene.add(sunLight);

  // Star background
  function createStars(count = 5000, spread = 1200) {
    const positions = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const idx = i * 3;
      positions[idx]   = (Math.random() - 0.5) * spread;
      positions[idx+1] = (Math.random() - 0.5) * spread * 0.6; // slightly flattened
      positions[idx+2] = (Math.random() - 0.5) * spread;
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.9,
      sizeAttenuation: true,
      depthWrite: false,
      transparent: true,
      opacity: 0.9
    });
    const points = new THREE.Points(geom, mat);
    scene.add(points);
  }
  createStars();

  // Planet creation function
  function createPlanet(size, color, distance) {
    const geometry = new THREE.SphereGeometry(size, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);

    const pivot = new THREE.Object3D();
    pivot.add(mesh);
    mesh.position.x = distance;

    scene.add(pivot);
    return { mesh, pivot };
  }

  // Sun
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(4, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0xFDB813 })
  );
  scene.add(sun);

  // Planets
  const mercury = createPlanet(0.5, 0xaaaaaa, 7);
  const venus   = createPlanet(1.0, 0xc68c53, 10);
  const earth   = createPlanet(1.2, 0x1f51ff, 14);
  const mars    = createPlanet(0.8, 0xff4500, 18);
  const jupiter = createPlanet(2.5, 0xd2b48c, 24);
  const saturn  = createPlanet(2.2, 0xd9c57c, 30);

  // Saturn rings (adjusted radii)
  const ringGeo = new THREE.RingGeometry(2.6, 4.2, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color:0xd9c57c, side: THREE.DoubleSide, transparent:true, opacity:0.95 });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = Math.PI / 2;
  saturn.mesh.add(ring);

  // Mouse look (VR-style) — handle pointer lock or normal mouse movement fallback
  let yaw = 0, pitch = 0;
  // Use pointermove if pointer locked (movementX available) else fallback to mousemove with client coords
  let pointerLocked = false;
  document.addEventListener('pointerlockchange', () => {
    pointerLocked = !!document.pointerLockElement;
  });

  document.addEventListener("mousemove", e => {
    // if movementX is zero (or not pointer locked) we still support small movement using clientX delta
    const moveX = (e.movementX !== undefined && e.movementX !== 0) ? e.movementX : (e.movementX || (e.clientX - (window._lastMouseX || e.clientX)));
    const moveY = (e.movementY !== undefined && e.movementY !== 0) ? e.movementY : (e.movementY || (e.clientY - (window._lastMouseY || e.clientY)));

    yaw -= moveX * 0.06;
    pitch -= moveY * 0.06;
    pitch = Math.max(-45, Math.min(45, pitch));
    camera.rotation.set(
      THREE.Math.degToRad(pitch),
      THREE.Math.degToRad(yaw),
      0
    );

    window._lastMouseX = e.clientX;
    window._lastMouseY = e.clientY;
  });

  // Try to request pointer lock on click for better movementX support
  window.addEventListener('click', () => {
    if (!document.pointerLockElement) {
      try { renderer.domElement.requestPointerLock(); } catch(e) { /* ignore */ }
    }
  });

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Animation loop
  let t = 0;
  function animate() {
    try {
      requestAnimationFrame(animate);
      t += 0.01;

      mercury.pivot.rotation.y = t * 4.7;
      venus.pivot.rotation.y   = t * 3.5;
      earth.pivot.rotation.y   = t * 3.0;
      mars.pivot.rotation.y    = t * 2.4;
      jupiter.pivot.rotation.y = t * 1.5;
      saturn.pivot.rotation.y  = t * 1.2;

      renderer.render(scene, camera);
    } catch (err) {
      showError('Render loop error: ' + err);
      // stop animation
    }
  }

  // Start
  animate();

})();
</script>
</body>
</html>
